<!DOCTYPE html><html lang="hu"><head><base href="/"><meta charset="utf-8"><meta><meta cache-control="max-age: 1800"><title>Architektúra tervezés</title><link href="http://fonts.googleapis.com/css?family=Open+Sans:300,600,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css"><script src="/js/jquery-1.9.1.min.js"></script><script src="/js/config.js"></script><script src="/js/skel.min.js"></script><script src="/js/moment.min.js"></script><noscript><link rel="stylesheet" href="/css/skel-noscript.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/style-desktop.css"></noscript><!--if lte IE 9link(rel="stylesheet", href="/css/ie9.css")--><!--if lte IE 8script(src="js/html5shiv.js")
link(rel="stylesheet", href="/css/ie8.css")--><!--if lte IE 7link(rel="stylesheet", href="/css/ie7.css")--><link rel="stylesheet" href="/css/opengov.css"></head><body><!-- Nav--><nav id="nav"><ul><li class="logo">OpenGov.hu</li></ul></nav><!-- Home--><div class="wrapper wrapper-style1 wrapper-first"><article id="top" class="container"><div class="row"><div class="4u"><span class="me image image-full"><img src="/images/tudas.jpg" alt=""></span></div><div class="8u"><header><p>Az architektúra tervezés alapkövetelményei</p><h1><strong>Architektúra tervezés</strong></h1><p>Egy jól kitalált architektúra a megvalósítást olcsóbbá teszi, meggyorsítja a bevezetést és megbízhatóvá, karbantarthatóvá teszi a  szoftvert.</p></header></div></div></article></div><!-- Content--><div class="wrapper wrapper-style1"><article id="work"><header><h2>Valljuk, hogy nem a termék oldja meg a problémát, hanem a megfelelő szakemberek.</h2><span>Nem a licenszek vásárlása, hanem az elvégzett munka, a szolgáltatás az, amely működő megoldásokat eredményez.</span></header><header></header><div class="container"><div class="row"><div class="1u">&nbsp;</div><div class="10u"><section class="text"><h3 id="szoftver-architekt-ra">Szoftver architektúra</h3>
<p>A jó szoftver architektúra egyik fő ismérve, hogy moduláris szerkezetű. A monolitikus szoftverek mindig problémát jelentenek, csökkentik a minőséget és a rendelkezésre állást. A szoftver architektúra több szinten valósítható meg:</p>
<ul>
<li>rendszerszinten: ekkor a különböző szoftverek egymáshoz kapcsolódását definiálja, ezt nevezzük <strong>rendszerszintű szoftver architektúrának,</strong></li>
<li>adott szoftver szinten: adott alkalmazás belső komponensei közötti kapcsolatot mutatja. Ennek jelentősége a monolitikus szoftverek eltűnésével jelentősen csökkent.</li>
</ul>
<p>A továbbiakban a rendszerszintű szoftver architektúrával foglalkozunk.</p>
<h3 id="jelent-s-ge">Jelentősége</h3>
<p>Egy rosszul megírt program javítható. <strong>Egy rosszul megtervezett szoftver architektúra alapján létrehozott rendszer javíthatatlan, mert maga a szoftver architektúra az amely hibás.</strong> Ekkor csak a komplett architektúrális megújítás segít, amely az esetek többségében a kapcsolódó szoftverek teljes újraírásával valósítható csak meg. <strong>Ezért a fejlesztési projektben a legfontosabb dolog a megbízható szoftver architektúra kialakítása.</strong></p>
<h3 id="megb-zhat-szoftver-architekt-ra">Megbízható szoftver architektúra</h3>
<p>A szoftver architektúra elsődleges követelménye, hogy rajta keresztül biztosítható legyen az igények kiszolgálása. Ehhez alapvetően az igényeket kell szem előtt tartani a szoftver architketúra tervezésekor. Nem szabad kompromisszumokat kötni! Minden kompromisszum, amely az igények kiszolgálásának minőségéből enged azt eredményezi, hogy a megvalósítási fázisban akár jelentősen is sérülhetnek ezek. <strong>Általánoságban elmondható, hogy egy kicsit rossz architektúra, sokkal rosszabb szoftvert eredményez, amely automatikusan jelenti a felhasználói igények jelentős minőség romlását.</strong> A szoftver architektúra minőségén a megvalósíthatóság, a felhasználói élmény, a használhatóság, a karbantarthatóság és az üzemeltethetőség múlik.</p>
<h3 id="t-nyez-k-a-tervez-skor">Tényezők a tervezéskor</h3>
<p>Az architektúra tervezésekor sok tényezőt figyelembe kell venni, de a legfontosabb az igények kiszolgálása. Ez nem jelenti azt, hogy a többi tényező rovására engedményeket lehet tenni. Az alábbiakat mindenképpen vegyük figyelembe:</p>
<ul>
<li>igények kiszolgálása</li>
<li>teljesítmény</li>
<li>megbízhatóság</li>
<li>tranzakciós határok</li>
<li>rendelkezésre állás</li>
<li>üzemeltethetőség</li>
<li>egyes komponensek leállásának következménye</li>
<li>több példányos működés</li>
<li>alapszoftverek licensz díja</li>
</ul>
<h3 id="tervez-s-k-vetelm-nyei">Tervezés követelményei</h3>
<ul>
<li><strong>Moduláris architektúrát tervezz!</strong> Az architekútrát mindenképpen úgy alakítsd, hogy az átalakítható legyen úgy, hogy a kapcsolódó szoftvereket ez minimálisan érintse. Az architktúrát ezért modulárisra kell tervezni.</li>
<li><strong>Lekérdezéskor mindig szinkron műveleteket használjunk!</strong> Ahol fontos a válaszidő, ott mindenképpen szinkron (http, websocket, socket) kapcsolatot használjunk, tipikusan ilyenek a lekérdezések. Sohase használjunk aszinkron működést, ezzel a rendszerünket védjük ugyan, de eredménye az alacsony teljesítmény, a kiszolgálás minőségének csökkenése és a jelentősen nagyobb és bonyolultabb szoftver.</li>
<li><strong>Teljesítmény növeléshez használjunk keseket!</strong> Gondoskodjunk a keselés tervezésekor a kes inicializálásáról és a kes invalidálásáról is.</li>
<li><strong>Idempotens legyen a rendszer!</strong> A rendszerünkben ismételhető legyen az üzenet úgy, hogy ha az többször is elküldésre kerül, akkor se okozzon problémát a rendszerünknek. Például egy külső fél akar karbantartó üzenetet küldeni felén, de épp nem tud, akkor később megismételhesse. Nagyon fontos, hogy nem lehetünk abban biztosak, hogy a küldő megkapta a feldolgozásunkról szóló visszajelzést, ezért fontos, hogy ugyanazt a kérést ismételve mindig ugyanazt a választ adjuk és a rendszrünkre ugyanazt a hatást gyakorolja. Természetesen ki lehet ezt váltani aszinkron működéssel, de ennek ára, hogy jelentősen csökken a teljesítmény magának az aszinkron működés elvéből fakadóan és bonyolultabb lesz a szoftver rendszerünk.</li>
<li><strong>Pontosan állapítsuk meg a tranzakció határokat!</strong> Például az email küldésben a tranzakció határ az SMTP szerver, nem pedig az email megérkezése a klienshez. Ugyanez igaz a nyomtatásra is: elküldtük a nyomtatónak az üzenetet, ez a tranzakciós határ.</li>
<li><strong>Tervezzük meg a tranzakciókat!</strong> A több szoftver komponenst érintő tranzakciót ne tekintsük egyszerűen megoldható szoftver szintű tranzakciónak (commit, 2 és 3 fázisú commit). Gondoljuk át például azt, hogy az ATM-ek esetében akár több bank is kapcsolatba kerül egymással, ahol esélytelen hogy egymás rendszerét írják. Gondolkozzunk <em>kompenzációs tranzakciókban is,</em> ha ilyen, elosztott tranzakciót tervezünk!</li>
<li><strong>&#39;Immutable&#39; (módosíthatatlan) adatkezelésben gondolkodjunk!</strong> Tipikusan a bankok és kormányzatok használnak olyan rendszereket, ahol a rögzített adatot meg kell őrizni úgy ahogy beérkezett. Ennek régebben biztonsági okai voltak, mára azonban felismerték, hogy az ilyen adattárolással nagymértékben leegyszerűsíthető a rendszer és brutálisan növelhető a teljesítmény (például relációs adatbázisok esetén nincs update, csak insert). A karbantartás oldalon redikálisan egyszerűsödik a logika, amelynek a következménye a programhibák csökkenése (banki rendszereknél pénzben mérhető) és a karbantarthatóság növekedése. Lekérdezés oldalon a horizontális skálázás elterjedésével (például NoSQL rendszerek) a teljesítmény olcsón növelhető. A hétköznapi életben a legjobb példa a számla előállítás, amely &#39;módosíthatatlan&#39; adattartalommal kell hogy rendelkezzen. Közigazgatásban a történeti adatok vagy okmányok kezelésekor használjuk ezt a megoldást.</li>
<li><strong>Elosztott rendszert tervezz!</strong> Még ha azt is gondolod, hogy a rendszered nem elosztott. Képzelj el egy georedundáns kialakítást, amely minden egyes helyen több példányban fut. Ha ilyen a rendszered, akkor elosztott rendszerre jellemző kérdések fognak felmerülni. Az elosztott rendszerekben a szerveren elhelyezett végpontok állapotmentesek (stateless), ez biztosítja a magas rendelkezésre állást és a dinamikus skálázhatóságot. Soha ne gondolkodj szerver oldali sessionben.</li>
<li><strong>Ne csak asztali gépekben, de mobil rendszerekben is gondolkodj!</strong> A mobil rendszerek sávszélessége olykor kicsi, ne legyen terjengős az adatszerkezet. Úgy tervezd meg a rendszert, hogy az natív mobil alkalmazásból, más gépi interfészről vagy akár böngészőből is ugyanazt az interfészt használja, tipikusan REST API-t szoktak ilyen céllal használni JSON adat formátummal.</li>
<li><strong>Vedd figyelembe a terhelést!</strong> Ha több ezer felhasználód van, akkor a régi technológiák (példul szinkron servlet hívás) olyan méretű teljesítmény igényt gerjesztenek, amely komoly beruházást igényelhetnek. Ezért néhány ezer felhasználó esetén (néhány száz kérés / másodperc) érdemes aszinkron rendszert fejleszteni (Jetty, Netty, VertX vagy NodeJS).</li>
<li><strong>Az alapszoftvereket válaszd az architektúrához, ne fordítva!</strong> Tipikus hiba amit el szoktak követni, hogy nem tartják be a tervezési folyamatot: igények alapján kell megtervezni az architektúrát, az architektúrához pedig ki kell választani az eszközöket. A valós életben több esetben megfigyelhető, hogy abszolút fordítva indultak el a rendszer felépítésében. Mivel a terméket kiválasztották és az igények is adottak voltak, ezért a megvalósítás lehetetlenné vált, mert a híd két oldala - az igény és eszköz - nem találkozott. Az ilyen döntések automatikusan és mindig a projekt kudarcát jelentik.</li>
</ul>
</section></div><div class="1u">&nbsp;</div></div></div></article></div><div class="wrapper wrapper-style4"><article id="contact"><header><h2>Kapcsolódj be a munkába!</h2><span>A munka önkéntes és nyílt. Munkáddal hozzájárulsz az egyszerűbb, és érthetőbb kormányzati informatikához!</span></header><div><div class="row row-special"><div class="12u"><h3>Itt megtalálsz minket...<ul class="social"><li class="twitter"><a href="http://twitter.com/@patoistvan" class="icon icon-twitter"><span>Twitter</span></a></li><li class="github"><a href="http://github.com/opengov-hu/opengov.hu" class="icon icon-github"><span>Github</span></a></li></ul></h3></div></div></div><footer><p id="copyright"><a rel="license" href="http://creativecommons.org/licenses/by/2.5/hu/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/2.5/hu/80x15.png"></a><br><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">OpenGov.hu teljes tartalma a&nbsp;<a rel="license" href="http://creativecommons.org/licenses/by/2.5/hu/deed.en_US">Creative Commons Attribution 2.5 Hungary License</a>&nbsp;alá tartozik.
Minden további névjegy és márkanév a megfelelő birtokosuk tulajdona.
Az oldal megjelenésére a Creative Commons Attribution 3.0 Unported licensz vonatkozik:
Images:&nbsp;<a href="http://fotogrph.com">fotogrph</a>&nbsp;Design:&nbsp;<a href="http://html5up.net/">HTML5 UP</a></span></p></footer></article></div></body></html>